<!DOCTYPE html>
<html>
<head>
    <title>Attribute Allocation by Project</title>
    <!--  (c) 2016 CA Technologies.  All Rights Reserved. -->
    <!--  Build Date: Wed Dec 07 2016 08:12:54 GMT-0800 (PST) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Wed Dec 07 2016 08:12:54 GMT-0800 (PST)";
        var BUILDER = "jmartin";
        var CHECKSUM = 35400233564;
    </script>
    
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350,
    
    informationalConfig: null,
    
    items: [{xtype:'container', itemId:'information' }],
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/var BUILDER = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
       
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
   
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    var stored_checksum = me._generateChecksum(text);
                    if ( CHECKSUM !== stored_checksum ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    _addToContainer: function(container){
        var config = Ext.apply({
            xtype:'container',
            height: 200,
            overflowY: true
        }, this.informationalConfig);
        
        container.add(config);
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if ( !Ext.isEmpty( this.informationalConfig ) ) {
            var container = this.down('#information');
            this._addToContainer(container);
            
        }
        
        if (! app.isExternal() ) {
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            dock: 'bottom',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml,
                doc: 'top'
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            dock:'bottom',
            html:"This app was created by the CA AC Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html: Ext.String.format("Build date/time: {0} ({1})",
                    APP_BUILD_DATE,
                    BUILDER)
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

//
// This class is tested.  Check the 'fast' automated tests before adding or modifying behavior!
//
Ext.define('TSCalculator',{
    singleton: true,

    getCategoryFromRecordData: function(recordData,fieldName,useParentAsDefault) {
        var val = recordData[fieldName];
        
        if ( useParentAsDefault && (!val || val == "None") ) {
            val = recordData.Parent && recordData.Parent[fieldName];
        }
        
        if ( Ext.isObject(val) ) {
            val = val._refObjectName;
        }
        
        if ( !val ) { 
            val = 'None';
        }
        return val;
    },
    
    getValueFromSumField: function(recordData, fieldName) {
        var val = recordData[fieldName] || 0;
        
        if ( Ext.isObject(val) ) {
            val = val.Value || 0;
        }
        
        return parseInt(val,10) || 0;
    },
    
    sortWithNone: function(array_to_sort) {
        var new_array = Ext.clone(array_to_sort);
        
        return new_array.sort(function(a,b){
            var compare_a_value = Ext.isString(a) ? a.toLowerCase() : a,
                compare_b_value = Ext.isString(b) ? b.toLowerCase() : b;
                
            if ( compare_a_value == "none" ) { compare_a_value = ' '; }
            if ( compare_b_value == "none" ) { compare_b_value = ' '; }
            
            if ( ''+compare_a_value < ''+compare_b_value ) { return -1; }
            if ( ''+compare_a_value > ''+compare_b_value ) { return 1;  }
            return 0;
        });
    },
    
    sortWithProjectUtility: function(oid_array,project_utility,defined_order) {
        var new_array = Ext.clone(oid_array);
        
        return new_array.sort(function(a,b){
            var diff = 0;
            if ( project_utility.classificationField ) {
                var compare_a_value = Ext.isNumber(a) ? project_utility.getClassification(a) : a,
                    compare_b_value = Ext.isNumber(b) ? project_utility.getClassification(b) : b;
                if ( !Ext.isEmpty(defined_order) ) { 
                    compare_a_value = Ext.Array.indexOf(defined_order, compare_a_value),
                    compare_b_value = Ext.Array.indexOf(defined_order, compare_b_value);
                    
                }
                if ( compare_a_value < compare_b_value ) { diff = -1; }
                if ( compare_a_value > compare_b_value ) { diff = 1;  }
                if ( diff !== 0 ) { return diff; }
            }
            
            // either the same classification or classification wasn't set
            var compare_a_name = Ext.isNumber(a) ? project_utility.getProjectName(a) : a,
                compare_b_name = Ext.isNumber(b) ? project_utility.getProjectName(b) : b;
                
            if ( compare_a_name < compare_b_name ) { return -1; }
            if ( compare_a_name > compare_b_name ) { return 1;  }
            return 0;
        });
    }

});
Ext.define('PortfolioItemCostTracking.promise.ParallelThrottle',{
    requires: ['Deft.promise.Promise'],
    statics: {

        throttle: function (fns, maxParallelCalls, scope) {
            
            if (maxParallelCalls <= 0 || fns.length < maxParallelCalls){
                return Deft.promise.Chain.parallel(fns, scope);
            }

            var parallelFns = [],
                fnChunks = [],
                idx = -1;

            for (var i = 0; i < fns.length; i++) {
                if (i % maxParallelCalls === 0) {
                    idx++;
                    fnChunks[idx] = [];
                }
                fnChunks[idx].push(fns[i]);
            }

            _.each(fnChunks, function (chunk) {
                parallelFns.push(function () {
                    return Deft.promise.Chain.parallel(chunk, scope);
                });
            });

            return Deft.Promise.reduce(parallelFns, function(groupResults, fnGroup) {
                return Deft.Promise.when(fnGroup.call(scope)).then(function(results) {
                    groupResults = groupResults.concat(results || []);
                    return groupResults;
                });
            }, []);
        }
    }
});
Ext.define('CA.technicalservices.utils.ProjectUtilities',{

    fetch: ['ObjectID','Name','Parent'],
    config: {
        classificationField: null
    },
    
    mixins: {
        observable: 'Ext.util.Observable'
    },
    constructor: function(config){
        this.mixins.observable.constructor.call(this, config);

//        var fetch = ['ObjectID','Name','Parent']
//        if (config.fetch){
//            fetch = Ext.Array.merge(fetch, config && config.fetch || []);
//        }

        this.mergeConfig(config);
        
        Ext.create('Rally.data.wsapi.Store',{
            model: 'Project',
            fetch: this.getFetch(),
            limit: Infinity,
            context: {project: null},
            compact: false,
            pageSize: 2000
        }).load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    this._buildProjectParentHash(records);
                } else {
                    this.fireEvent('onerror', "Error fetching projects: " + operation.error && operation.error.errors.join(','));
                }
            },
            scope: this
        });
    },
    
    getFetch: function() {
        var fetch = this.fetch;
        if ( this.classificationField ) {
            fetch.push(this.classificationField);
        }
        return fetch;
    },
    
    _buildProjectParentHash: function(records){

        var projectHash = {};
        Ext.Array.each(records, function(r){
            projectHash[r.get('ObjectID')] = r.getData();
        });
        this.projectHash= projectHash;
        this.fireEvent('ready');
    },
    //getProjectAncestor: function(projectID, relativeProjectLevel){
    //    var actualProjectLevel =
    //
    //    var parent = this.projectHash[projectID].Parent && this.projectHash[projectID].Parent.ObjectID || null,
    //        ancestry = this.projectHash[projectID] && this.projectHash[projectID].ancestors;
    //
    //    if (!ancestry){
    //        ancestry = [projectID];
    //        if (parent){
    //            do {
    //                ancestry.unshift(parent);
    //                parent = this.projectHash[parent] &&
    //                    this.projectHash[parent].Parent &&
    //                    this.projectHash[parent].Parent.ObjectID || null;
    //
    //            } while (parent);
    //        }
    //        this.projectHash[projectID].ancestors = ancestry;
    //    }
    //    if (ancestry.length >= projectLevel){
    //        return ancestry[projectLevel - 1];
    //    }
    //    return null;
    //},
    getAncestry: function(projectID){
        var parent = this.projectHash[projectID].Parent && this.projectHash[projectID].Parent.ObjectID || null,
            ancestry = this.projectHash[projectID] && this.projectHash[projectID].ancestors;

        if (!ancestry){
            ancestry = [projectID];
            if (parent){
                do {
                    ancestry.unshift(parent);
                    parent = this.projectHash[parent] &&
                        this.projectHash[parent].Parent &&
                        this.projectHash[parent].Parent.ObjectID || null;

                } while (parent);
            }
            this.projectHash[projectID].ancestors = ancestry;
        }
        return ancestry;
    },
    getCurrentProjectLevel: function(){
        if (!this.currentProjectLevel){
            this.currentProjectLevel = this.getProjectLevel(this.currentProject);
        }
        return this.currentProjectLevel;
    },
    getProjectAncestor: function(projectID, relativeProjectLevel){
        var absoluteProjectLevel = this.getCurrentProjectLevel() + relativeProjectLevel;
        var ancestry = this.getAncestry(projectID);

        if (ancestry.length >= absoluteProjectLevel){
            return ancestry[absoluteProjectLevel - 1];
        }
        return null;
    },
    
    getClassification: function(projectID){
        if ( Ext.isEmpty(this.classificationField) ) {
            return null;
        }
        var project = this.getProjectFromOID(projectID);
        return project[this.classificationField];
    },
    
    getProjectFromOID: function(projectID){
        return this.projectHash[projectID];
    },
    
    getProjectName: function(projectID){
        return this.projectHash[projectID] &&  this.projectHash[projectID].Name || "Unknown";
    },
    getProjectLevel: function(projectID){
        var ancestory = this.getAncestry(projectID);
        return ancestory.length;
    }
});
Ext.define('CA.agile.technicalservices.util.WsapiUtils',{
    singleton: true,
    
    // given a store config, loads the records while returning a promise
    loadWsapiRecords: function(config) {
        var deferred = Ext.create('Deft.Deferred');

        Ext.create('Rally.data.wsapi.Store',config).load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    deferred.resolve(records);
                } else {
                    deferred.reject(operation.error.errors.join(','));
                }
            }
        });
        return deferred.promise;
    },
    
    getPortfolioItemTypes: function(workspace) {
        var deferred = Ext.create('Deft.Deferred');
                
        var store_config = {
            fetch: ['Name','ElementName','TypePath'],
            model: 'TypeDefinition',
            filters: [
                {
                    property: 'TypePath',
                    operator: 'contains',
                    value: 'PortfolioItem/'
                }
            ],
            sorters: [ {property:'Ordinal', direction: 'ASC'}],
            autoLoad: true,
            listeners: {
                load: function(store, records, successful) {
                    if (successful){
                        deferred.resolve(records);
                    } else {
                        deferred.reject('Failed to load types');
                    }
                }
            }
        };
        
        if ( !Ext.isEmpty(workspace) ) {
            store_config.context = { 
                project:null,
                workspace: workspace._ref ? workspace._ref : workspace.get('_ref')
            };
        }
                
        var store = Ext.create('Rally.data.wsapi.Store', store_config );
                    
        return deferred.promise;
    },
    
    loadWsapiRecordsParallel: function(store_config){
        var deferred = Ext.create('Deft.Deferred'),
            promises = [],
            thread_count = 9,
            me = this;

        var config = Ext.Object.merge({
            pageSize: 2000
        },store_config);
        
        config.autoLoad = false;
        config.limit    = config.pageSize;
        
        this.fetchWsapiCount(store_config).then({
            success: function(totalCount){
                var store = Ext.create('Rally.data.wsapi.Store', config),
                    totalPages = Math.ceil(totalCount/config.pageSize);

                var pages = _.range(1,totalPages+1,1);

                _.each(pages, function(page){
                    promises.push(function () {
                        return me.loadStorePage(page, store);
                    });
                });

                PortfolioItemCostTracking.promise.ParallelThrottle.throttle(promises, thread_count, me).then({
                    success: function(results){
                        deferred.resolve(_.flatten(results));
                    },
                    failure: function(msg){
                        deferred.reject(Ext.String.format("Parallel Load Problem:", msg));
                    }
                });
            },
            failure: function(msg){
                deferred.reject(msg);
            }
        });
        return deferred;
    },
    
    fetchWsapiCount: function(store_config){
        var deferred = Ext.create('Deft.Deferred');

        var config = Ext.Object.merge(store_config, {
            fetch: ['ObjectID'],
            limit: 1,
            pageSize: 1
        });
        
        Ext.create('Rally.data.wsapi.Store',config).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(operation.resultSet.totalRecords);
                } else {
                    deferred.reject(Ext.String.format("Count Problem: {1}", operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    },
    
    loadStorePage: function(pageNum, store){
        var deferred = Ext.create('Deft.Deferred');
        
        store.loadPage(pageNum, {
            callback: function(records, operation){
                
                if (operation.wasSuccessful()){
                     deferred.resolve(records);
                } else {
                    console.error('Operation:', operation);
                    var msg = operation.error && operation.error.errors.join(',');
                    if ( Ext.isEmpty(msg) ) {
                        deferred.reject('Network issue while loading store page');
                    } else {
                        deferred.reject(msg + " (lsp)");
                    }
                }
            }
        });

        return deferred;
    },
    
    fetchAllowedValues: function(model_name, field_name) {
        var deferred = Ext.create('Deft.Deferred');
        console.log(model_name, field_name);
        
        Rally.data.ModelFactory.getModel({
            type: model_name,
            success: function(model) {
                model.getField(field_name).getAllowedValueStore().load({
                    callback: function(allowed_values, operation, success) {
                        deferred.resolve(Ext.Array.map(allowed_values, function(allowed_value){
                            return allowed_value.get('StringValue');
                        }));
                    }
                });
            }
        });
        return deferred.promise;
    }
    
});
Ext.override(Rally.data.lookback.SnapshotRestProxy, {
    timeout: 300000
});
Ext.override(Rally.data.wsapi.Proxy, {
    timeout: 300000
});

Ext.define("attribute-allocation-by-project", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    defaults: { margin: 10 },

    integrationHeaders : {
        name : "techservices.attribute-allocation-by-project"
    },

    config: {
        defaultSettings: {
            projectLevel: 2,
            attributeField: 'InvestmentCategory',
            artifactType: 'PortfolioItem/Feature',
            projectClassificationField: null,
            showProjectClassifications: false,
            chartType: 'column',  //'bar' is other choice,
            query: '', //filters the results - for example if I just want to see items in a few particular states.,
            chartTitle: 'Chart Title',
            sumField: null  //or storyCount or storyPoints or featurePreliminaryEstimate
        }
    },

    chartColors: ['#FF671B','#F38B00','#FFC81F','#8DB92E'],
    artifactFetch: ['Project','ObjectID','Parent'],  //we need to get the parent so that we can also fetch the attribute field value of the parent.

    launch: function() {
        this.logger.log('launch', this._validateAppSettings());
        if (!this._validateAppSettings()){
           this.showAppMessage('Please configure an Artifact Type and Attribute Field setting.');
           return;
        }
        
        Deft.Chain.sequence([
            CA.agile.technicalservices.util.WsapiUtils.getPortfolioItemTypes,
            this.fetchAllowedClassifications
        ],this).then({ 
            success: function(results) {
                this.PortfolioItemTypes = results[0];
                this.AllowedValues = results[1];
                
                this._initializeApp();
            },
            scope: this
        });
    },
    _validateAppSettings: function(){
        this.logger.log('_validateAppSettings', this.getAttributeField(), this.getArtifactType());
        return this.getAttributeField() && this.getAttributeField().length > 0 &&
                this.getArtifactType() && this.getArtifactType().length > 0;
    },
    _initializeApp: function(){
        this.removeAll();
        this.logger.log('_initializeApp');
        this.projectUtility = Ext.create('CA.technicalservices.utils.ProjectUtilities',{
            classificationField: this.shouldShowClassification() ? this.getProjectClassificationField() : null,
            currentProject: this.getContext().getProject().ObjectID,
            listeners: {
                onerror: this.showErrorNotification,
                ready: this.fetchArtifacts,
                scope: this
            }
        });
    },
    
    fetchArtifacts: function(){
        var me = this;
        this.setLoading(true);
        
        Deft.Chain.pipeline([
            this._fetchParentArtifacts,
            this._fetchChildArtifacts,
            this.buildChart
        ],this).then({
            failure: function(msg) {
                var msg = Ext.String.format("Error fetching {0} artifacts: {1}",this.getArtifactType(),msg);
                this.showErrorNotification(msg);
            },
            scope: this
        }).always(function() { me.setLoading(false); });
    },
    
    // This fetches the configured artifact type
    _fetchParentArtifacts: function() {
        this.setLoading("Fetching " + this.getArtifactType() + "s...");

        var config = {
            model   : this.getArtifactType(),
            fetch   : this.getArtifactFetch(),
            filters : this.getArtifactFilters(),
            limit   : Infinity,
            pageSize: 2000,
            compact : false
        };
        
        return CA.agile.technicalservices.util.WsapiUtils.loadWsapiRecordsParallel(config);
    },
    
    // If feature is chosen, we skip this step
    // If initiative is chosen, we use that to constrain which features to get
    _fetchChildArtifacts: function(initiatives) {
        if ( this.getArtifactType() == this.getLowestLevelPITypePath() ) {
            return initiatives;
        }
        this.setLoading("Fetching " + this.getLowestLevelPITypePath() + "s...");
        
        var filter_array = Ext.Array.map(initiatives, function(initiative){
            return {property:'Parent.ObjectID',value:initiative.get('ObjectID')};
        });
        
        if ( filter_array.length == 0 ) {
            filter_array = [{property:'Parent.ObjectID',value:-1}];
        }
        
        this.logger.log('_fetchChildArtifacts with # of filters: ', filter_array.length);
        
        var config = {
            model   : this.getLowestLevelPITypePath(),
            fetch   : this.getArtifactFetch(),
            filters : Rally.data.wsapi.Filter.or(filter_array),
            limit   : Infinity,
            pageSize: 2000,
            compact : false,
            context: {project: null},
            enablePostGet: true
        };
        
        return CA.agile.technicalservices.util.WsapiUtils.loadWsapiRecordsParallel(config);
    },
    
    prepareChartData: function(records) {
        this.setLoading('Preparing Data....');
        
        var field = this.getAttributeField(),
            sumField = this.getSumField();
        
        var hash = {},
            groupingKeys = [],
            projectKeys = [];
    
        for (var i=0; i<records.length; i++){
            var rec = records[i].getData();
    
            var use_parent = (this.getArtifactType() != this.getLowestLevelPITypePath());
            
            var group_name = TSCalculator.getCategoryFromRecordData(rec,field,use_parent);
            
            var project_oid = this.projectUtility.getProjectAncestor(rec.Project.ObjectID, this.getProjectLevel());
            if ( this.getArtifactType() != this.getLowestLevelPITypePath() ) {
                if ( !rec.Parent ) {
                    continue;
                }
                project_oid = this.projectUtility.getProjectAncestor(rec.Parent.Project.ObjectID, this.getProjectLevel());
            }
            
            if (project_oid){
                groupingKeys = Ext.Array.merge(groupingKeys, [group_name]);
                projectKeys = Ext.Array.merge(projectKeys, [project_oid]);
                
                if (!hash[group_name]){
                    hash[group_name] = {};
                }
                if (!hash[group_name][project_oid]){
                    hash[group_name][project_oid] = 0;
                }
    
                if (sumField){
                    hash[group_name][project_oid] += TSCalculator.getValueFromSumField(rec,sumField);
                } else {
                    hash[group_name][project_oid]++;
                }
            }
        }
    
        var series = [],
            project_oids_in_order = TSCalculator.sortWithProjectUtility(projectKeys,this.projectUtility,this.AllowedValues);

        var categories = Ext.Array.map(project_oids_in_order,function(oid){
            return this.projectUtility.getProjectName(oid);
        },this);
        
        Ext.Array.each(TSCalculator.sortWithNone(groupingKeys), function(group_name) {
            var data = [];
            Ext.Array.each(project_oids_in_order, function(project_oid){
                data.push( hash[group_name][project_oid] || 0 );
            });
            var series_data = {
                name: group_name,
                data: data
            };
            
            if ( group_name == 'None' ) {
                series_data.color = '#a3a3a3';
            }
            
            series.push(series_data);
        });
        
        return {
            series: series,
            categories: categories,
            plotBands: this._getPlotBands(project_oids_in_order)
        };
    },
    
    _getPlotBands: function(project_oids) {
        // assuming project_oids are already in category order
        if ( this.getSetting('chartType') == 'bar' ) { return; }
        
        var plot_bands = [];
        var align = ( this.getSetting('chartType') == 'column' ) ? 'center' : 'right';
        
        var classifications = {};
        Ext.Array.each(project_oids, function(project_oid,idx){
            var classification = this.projectUtility.getClassification(project_oid);
            if ( Ext.isEmpty(classification) ) { return; }
            
            if ( Ext.isEmpty(classifications[classification]) ) {
                classifications[classification] = [];
            }
            classifications[classification].push(idx);
        },this);
        
        var last_color = null,
            last_offset = null;
        
        Ext.Object.each(classifications, function(classification,indices){
            if ( Ext.isEmpty(classification) ) {
                return;
            }
            
            var color = '#ccc',
                offset = 20;
            
            if ( last_color == '#ccc' ) { color = '#eee'; }
            if ( last_offset === 20 ) { offset = 40; }
            
            var from = Ext.Array.min(indices) - 0.5,
                to   = Ext.Array.max(indices) + 0.5;
            plot_bands.push({
                color: color,
                from: from,
                to: to,
                label: {
                    text: classification,
                    align: align,
                    y: offset,
                    useHTML: true // so it sits on top of all the plot bands
                },
                
//                borderColor: '#fff',
//                borderWidth: 2
            });
            last_color = color;
            last_offset = offset;
        });
        
        return plot_bands;
    },
    
    buildChart: function(records){
        this.logger.log('buildRecords');

        if (records.length === 0){
            this.showAppMessage("No records found for the selected criteria.");
            return;
        }
        this.setLoading('Preparing Data....');

        var chart_data = this.prepareChartData(records);
        var plot_bands = chart_data.plotBands || [];
                
        var height = Math.max(400,chart_data.categories.length * 30);
        var yMax   = 100;
        
        if ( this.getChartType().toLowerCase() == "column" ) {
            height = Math.max(300,this.getHeight()-50);
            if ( this.shouldShowClassification() ) {
                yMax   = 120;
            }
        }
        
        this.add({
            xtype: 'rallychart',
            height: height,
            chartColors: this.chartColors,
            chartData: chart_data,
            chartConfig: {
                chart: {
                    type: this.getChartType()
                },
                title: {
                    text: this.getChartTitle(),
                    style: {
                        color: '#666',
                        fontSize: '18px',
                        fontFamily: 'ProximaNova',
                        fill: '#666'
                    }
                },
                xAxis: {
                    categories: chart_data.categories,
                    plotBands: plot_bands,
                    
                    labels: {
                        style: {
                            color: '#444',
                            fontFamily:'ProximaNova',
                            textTransform: 'uppercase',
                            fill:'#444'
                        }
                    }
                },
                yAxis: {
                    min: 0,
                    max: yMax,
                    labels: {
                        format: "{value}%",
                        style: {
                            color: '#444',
                            fontFamily:'ProximaNova',
                            textTransform: 'uppercase',
                            fill:'#444'
                        }
                    },
                    title: {
                        text: null
                    }

                },
                tooltip: {
                    pointFormat: '<span style="font-family:ProximaNova;color:{series.color}">{series.name}</span>: <span style="font-family:ProximaNova;color:white;">{point.y} ({point.percentage:.0f}%)</span><br/>',
                    backgroundColor: '#444',
                    headerFormat: '<span style="display:block;margin:0;padding:0 0 2px 0;text-align:center"><b style="font-family:NotoSansBold;color:white;">{point.key}</b></span><table><tbody>',
                    footerFormat: '</tbody></table>',
                    shared: true,
                    useHTML: true,
                    borderColor: '#444'
                },
                legend: {
                    itemStyle: {
                        color: '#444',
                        fontFamily:'ProximaNova',
                        textTransform: 'uppercase'
                    },
                    borderWidth: 0
                },
                plotOptions: {
                    series: {
                        stacking: 'percent'
                    }
                }
            }
        });
        
        this.setLoading(false);
        return;
    },
    showAppMessage: function(msg){
        this.removeAll();
        var ct = this.add({
            xtype: 'container',
            tpl: '<div class="no-data-container"><div class="secondary-message">{message}</div></div>'
        });
        ct.update({message: msg});
    },
    showErrorNotification: function(msg){
        this.logger.log('showErrorNotification', msg);
        Rally.ui.notify.Notifier.showError({message: msg});
    },
    getProjectClassificationField: function(){
        return this.getSetting('projectClassificationField');
    },
    getChartType: function(){
        return this.getSetting('chartType');
    },
    getChartTitle: function(){
        return this.getSetting('chartTitle');
    },
    getAttributeField: function(){
        return this.getSetting('attributeField');
    },
    getArtifactType: function(){
        return this.getSetting('artifactType');
    },
    getLowestLevelPITypePath: function() {
        return this.PortfolioItemTypes[0].get('TypePath');
    },
    fetchAllowedClassifications: function() {
        var model = 'Project',
            field = this.getProjectClassificationField();
        
        if ( !this.shouldShowClassification() ) { return null; }
        return CA.agile.technicalservices.util.WsapiUtils.fetchAllowedValues(model,field);
    },
    
    shouldShowClassification: function() {
        this.logger.log('shouldShowClassification', this.getSetting('showProjectClassification'));
        return this.getSetting('showProjectClassification');
    },
    getSumField: function(){
        if (this.getSetting('sumField') && this.getSetting('sumField') === "PreliminaryEstimate"){
            return 'PreliminaryEstimateValue';
        }
        return this.getSetting('sumField') || null;
    },
    getArtifactFetch: function(){
        var fetch = Ext.Array.merge(this.artifactFetch, [this.getAttributeField()]);
        if (this.getSumField()){
            fetch.push(this.getSumField());
        }
        return fetch;
    },
    getArtifactFilters: function(){
        var queryFilter = [];
        if (this.getSetting('query')){
            queryFilter = Rally.data.wsapi.Filter.fromQueryString(this.getSetting('query'));
        }
        return queryFilter;
    },
    getProjectLevel: function(){
        return this.getSetting('projectLevel') || 1;
    },
    getSettingsFields: function(){
        var labelWidth = 200,
            showProjectClassification = this.getSetting('showProjectClassification') || false,
            chartType = this.getChartType();

        return [{
            xtype: 'rallynumberfield',
            name: 'projectLevel',
            minValue: 1,
            maxValue: 9,
            fieldLabel: 'Relative Project Level',
            labelAlign: 'right',
            labelWidth: labelWidth
        },{
            xtype: 'rallycombobox',
            name: 'artifactType',
            storeConfig: {
                model: 'TypeDefinition',
                filters: [{
                    property: 'TypePath',
                    operator: 'contains',
                    value: 'PortfolioItem/'
                },{
                    property:'Ordinal',
                    operator: '<',
                    value: 2
                }],
                remoteFilter: true
            },
            fieldLabel: 'Artifact Type',
            labelAlign: 'right',
            labelWidth: labelWidth,
            valueField: 'TypePath',
            bubbleEvents: ['select','ready']
        },{
            xtype: 'rallyfieldcombobox',
            name: 'attributeField',
            model: 'PortfolioItem/Feature',
            fieldLabel: 'Attribute Type',
            labelAlign: 'right',
            labelWidth: labelWidth,
            _isNotHidden: function(field) {

                var blackList = ['Subscription','Workspace','Parent',
                    'RevisionHistory','PortfolioItemType'];  
                
                if (Ext.Array.contains(blackList, field.name)) { return false; }
                
                if ( field.hidden ) { return false; }
                var defn = field.attributeDefinition;
                if ( !field.attributeDefinition) { return false; }
                
                if ( defn.AttributeType == 'STRING' && defn.Constrained ) {
                    return true;
                }       
                if ( defn.AttributeType == 'RATING' ) {
                    return true;
                }
                
                if (defn.AttributeType == "OBJECT" ) {
                    return true;
                }
                
                return false;
            },
            handlesEvents: {
                ready: function(cb){
                    if (cb.getValue()){
                        this.refreshWithNewModelType(cb.getValue());
                    }
                },
                select: function(cb){
                    if (cb.getValue()){
                        this.refreshWithNewModelType(cb.getValue());
                    }
                }
            }
        },{
            xtype: 'rallyfieldcombobox',
            name: 'sumField',
            model: 'PortfolioItem/Feature',
            fieldLabel: 'Sum Field',
            labelAlign: 'right',
            labelWidth: labelWidth,
            allowNoEntry: true,
            noEntryText: 'Feature Count',
            _isNotHidden: function(field){
                var allowedFields = ['PreliminaryEstimate','RefinedEstimate','LeafStoryCount','LeafStoryPlanEstimateTotal','AcceptedLeafStoryPlanEstimateTotal','AcceptedLeafStoryCount'];
                return Ext.Array.contains(allowedFields, field.name);

                //return (field.name === 'PreliminaryEstimate') ||
                //    (field.attributeDefinition && (field.attributeDefinition.AttributeType === 'QUANTITY' ||
                //            field.attributeDefinition.AttributeType === 'DECIMAL' ||
                //            field.attributeDefinition.AttributeType === 'INTEGER'));
            },
            handlesEvents: {
                ready: function(cb){
                    if (cb.getValue()){
                        this.refreshWithNewModelType(cb.getValue());
                    }
                },
                select: function(cb){
                    if (cb.getValue()){
                        this.refreshWithNewModelType(cb.getValue());
                    }
                }
            }
        },{
            xtype: 'rallycheckboxfield',
            name: 'showProjectClassification',
            bubbleEvents: ['change'],
            fieldLabel: 'Show Project Classifications',
            labelAlign: 'right',
            labelWidth: labelWidth,
            value: showProjectClassification

        },{
            xtype: 'rallyfieldcombobox',
            name: 'projectClassificationField',
            model: 'Project',
            fieldLabel: 'Project Classification Field',
            labelAlign: 'right',
            labelWidth: labelWidth,
            disabled: showProjectClassification !== true,
            handlesEvents: {
                change: function(chk, newValue) {
                    this.setDisabled(newValue !== true);
                }
            },
            _isNotHidden: function(field) {
                var blackList = ['Subscription','Workspace','Parent',
                    'RevisionHistory','PortfolioItemType'];  
                
                if (Ext.Array.contains(blackList, field.name)) { return false; }
                
                if ( field.hidden ) { return false; }
                var defn = field.attributeDefinition;
                if ( !field.attributeDefinition) { return false; }
                
                if ( defn.AttributeType == 'STRING' && defn.Constrained ) {
                    return true;
                }       
                if (defn.AttributeType == "OBJECT" ) {
                    return true;
                }
                
                return false;
            }
        },{
            xtype: 'radiogroup',
            fieldLabel: 'Chart Type',
            labelAlign: 'right',
            labelWidth: labelWidth,
            // Arrange radio buttons into two columns, distributed vertically
            columns: 6,
            vertical: true,
            items: [
                { boxLabel: 'Column', name: 'chartType', inputValue: 'column', checked: chartType === 'column'},
                { boxLabel: 'Bar', name: 'chartType', inputValue: 'bar', checked: chartType === 'bar' }
            ]
        },{
            xtype: 'rallytextfield',
            name: 'chartTitle',
            fieldLabel: 'Chart Title',
            labelAlign: 'right',
            labelWidth: labelWidth,
            emptyText: 'Enter a Chart Title...',
            maxLength: 255,
            anchor: '100%',
            margin: '0 70 0 0'
        },{
            xtype: 'textarea',
            fieldLabel: 'Query Filter',
            name: 'query',
            anchor: '100%',
            cls: 'query-field',
            margin: '10 70 0 0',
            labelAlign: 'right',
            labelWidth: labelWidth,
            plugins: [
                {
                    ptype: 'rallyhelpfield',
                    helpId: 194
                },
                'rallyfieldvalidationui'
            ],
            validateOnBlur: false,
            validateOnChange: false,
            validator: function(value) {
                try {
                    if (value) {
                        Rally.data.wsapi.Filter.fromQueryString(value);
                    }
                    return true;
                } catch (e) {
                    return e.message;
                }
            }
        }];
    },
    
    getOptions: function() {
        return [
            {
                text: 'About...',
                handler: this._launchInfo,
                scope: this
            }
        ];
    },
    
    _launchInfo: function() {
        if ( this.about_dialog ) { this.about_dialog.destroy(); }
        this.about_dialog = Ext.create('Rally.technicalservices.InfoLink',{});
    },
    
    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
    }
});

            
               Rally.launchApp('attribute-allocation-by-project', {
                   name: 'Attribute Allocation by Project'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}

    </style>

</head>
<body></body>
</html>